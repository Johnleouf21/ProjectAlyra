{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-fd91739be6687c0c8cc27e3d211e1d82f33f7036",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Voting.sol": "project/contracts/Voting.sol",
    "contracts/VotingOptimized.sol": "project/contracts/VotingOptimized.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/access/Ownable.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Context.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/Voting.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n\ncontract Voting is Ownable {\n\n\n    uint public winningProposalID;\n    \n    struct Voter {\n        bool isRegistered;\n        bool hasVoted;\n        uint votedProposalId;\n    }\n\n    struct Proposal {\n        string description;\n        uint voteCount;\n    }\n\n    enum  WorkflowStatus {\n        RegisteringVoters,\n        ProposalsRegistrationStarted,\n        ProposalsRegistrationEnded,\n        VotingSessionStarted,\n        VotingSessionEnded,\n        VotesTallied\n    }\n\n    WorkflowStatus public workflowStatus;\n    Proposal[] proposalsArray;\n    mapping (address => Voter) voters;\n\n\n    event VoterRegistered(address voterAddress); \n    event WorkflowStatusChange(WorkflowStatus previousStatus, WorkflowStatus newStatus);\n    event ProposalRegistered(uint proposalId);\n    event Voted (address voter, uint proposalId);\n\n    constructor(address _addr) payable Ownable(msg.sender) {  \n        addVoter(_addr);\n      }\n\n    \n    modifier onlyVoters() {\n        require(voters[msg.sender].isRegistered, \"You're not a voter\");\n        _;\n    }\n    \n    // on peut faire un modifier pour les états\n\n    // ::::::::::::: GETTERS ::::::::::::: //\n\n    function getVoter(address _addr) external onlyVoters view returns (Voter memory) {\n        return voters[_addr];\n    }\n    \n    function getOneProposal(uint _id) external onlyVoters view returns (Proposal memory) {\n        return proposalsArray[_id];\n    }\n\n \n    // ::::::::::::: REGISTRATION ::::::::::::: // \n\n    function addVoter(address _addr) public onlyOwner {\n        require(workflowStatus == WorkflowStatus.RegisteringVoters, 'Voters registration is not open yet');\n        require(voters[_addr].isRegistered != true, 'Already registered');\n    \n        voters[_addr].isRegistered = true;\n        emit VoterRegistered(_addr);\n    }\n \n\n    // ::::::::::::: PROPOSAL ::::::::::::: // \n\n    function addProposal(string calldata _desc) external onlyVoters {\n        require(workflowStatus == WorkflowStatus.ProposalsRegistrationStarted, 'Proposals are not allowed yet');\n        require(keccak256(abi.encode(_desc)) != keccak256(abi.encode(\"\")), 'Vous ne pouvez pas ne rien proposer'); // facultatif\n        // voir que desc est different des autres\n\n        Proposal memory proposal;\n        proposal.description = _desc;\n        proposalsArray.push(proposal);\n        // proposalsArray.push(Proposal(_desc,0));\n        emit ProposalRegistered(proposalsArray.length-1);\n    }\n\n    // ::::::::::::: VOTE ::::::::::::: //\n\n    function setVote( uint _id) external onlyVoters {\n        require(workflowStatus == WorkflowStatus.VotingSessionStarted, 'Voting session havent started yet');\n        require(voters[msg.sender].hasVoted != true, 'You have already voted');\n        require(_id < proposalsArray.length, 'Proposal not found'); // pas obligé, et pas besoin du >0 car uint\n\n        voters[msg.sender].votedProposalId = _id;\n        voters[msg.sender].hasVoted = true;\n        proposalsArray[_id].voteCount++;\n\n        emit Voted(msg.sender, _id);\n    }\n\n    // ::::::::::::: STATE ::::::::::::: //\n\n\n    function startProposalsRegistering() external onlyOwner {\n        require(workflowStatus == WorkflowStatus.RegisteringVoters, 'Registering proposals cant be started now');\n        workflowStatus = WorkflowStatus.ProposalsRegistrationStarted;\n        \n        Proposal memory proposal;\n        proposal.description = \"GENESIS\";\n        proposalsArray.push(proposal);\n        \n        emit WorkflowStatusChange(WorkflowStatus.RegisteringVoters, WorkflowStatus.ProposalsRegistrationStarted);\n    }\n\n    function endProposalsRegistering() external onlyOwner {\n        require(workflowStatus == WorkflowStatus.ProposalsRegistrationStarted, 'Registering proposals havent started yet');\n        workflowStatus = WorkflowStatus.ProposalsRegistrationEnded;\n        emit WorkflowStatusChange(WorkflowStatus.ProposalsRegistrationStarted, WorkflowStatus.ProposalsRegistrationEnded);\n    }\n\n    function startVotingSession() external onlyOwner {\n        require(workflowStatus == WorkflowStatus.ProposalsRegistrationEnded, 'Registering proposals phase is not finished');\n        workflowStatus = WorkflowStatus.VotingSessionStarted;\n        emit WorkflowStatusChange(WorkflowStatus.ProposalsRegistrationEnded, WorkflowStatus.VotingSessionStarted);\n    }\n\n    function endVotingSession() external onlyOwner {\n        require(workflowStatus == WorkflowStatus.VotingSessionStarted, 'Voting session havent started yet');\n        workflowStatus = WorkflowStatus.VotingSessionEnded;\n        emit WorkflowStatusChange(WorkflowStatus.VotingSessionStarted, WorkflowStatus.VotingSessionEnded);\n    }\n\n\n   function tallyVotes() external onlyOwner {\n       require(workflowStatus == WorkflowStatus.VotingSessionEnded, \"Current status is not voting session ended\");\n       uint _winningProposalId;\n      for (uint256 p = 0; p < proposalsArray.length; p++) {\n           if (proposalsArray[p].voteCount > proposalsArray[_winningProposalId].voteCount) {\n               _winningProposalId = p;\n          }\n       }\n       winningProposalID = _winningProposalId;\n       \n       workflowStatus = WorkflowStatus.VotesTallied;\n       emit WorkflowStatusChange(WorkflowStatus.VotingSessionEnded, WorkflowStatus.VotesTallied);\n    }\n}"
      },
      "project/contracts/VotingOptimized.sol": {
        "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.28;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n/// @title Voting Contract - Optimized and Secured\n/// @author Alyra\n/// @notice This contract implements a secure and gas-optimized voting system\n/// @dev Implements Checks-Effects-Interactions pattern and uses ReentrancyGuard\ncontract VotingOptimized is Ownable, ReentrancyGuard {\n\n    /// @notice ID of the winning proposal after tally\n    uint256 public winningProposalID;\n\n    /// @notice Struct representing a voter\n    /// @dev Packed to optimize storage (1 slot)\n    struct Voter {\n        bool isRegistered;\n        bool hasVoted;\n        uint256 votedProposalId;\n    }\n\n    /// @notice Struct representing a proposal\n    struct Proposal {\n        string description;\n        uint256 voteCount;\n    }\n\n    /// @notice Enum representing the different workflow statuses\n    enum WorkflowStatus {\n        RegisteringVoters,\n        ProposalsRegistrationStarted,\n        ProposalsRegistrationEnded,\n        VotingSessionStarted,\n        VotingSessionEnded,\n        VotesTallied\n    }\n\n    /// @notice Current workflow status\n    WorkflowStatus public workflowStatus;\n\n    /// @notice Array of all proposals\n    Proposal[] public proposalsArray;\n\n    /// @notice Mapping of voter addresses to their info\n    mapping(address => Voter) public voters;\n\n    /// @notice Total number of registered voters (for optimization)\n    uint256 public votersCount;\n\n    // Events\n    event VoterRegistered(address voterAddress);\n    event WorkflowStatusChange(WorkflowStatus previousStatus, WorkflowStatus newStatus);\n    event ProposalRegistered(uint256 proposalId);\n    event Voted(address voter, uint256 proposalId);\n\n    // Custom Errors (more gas efficient than require strings)\n    error NotVoter();\n    error AlreadyRegistered();\n    error VotersRegistrationNotOpen();\n    error ProposalsRegistrationNotStarted();\n    error EmptyProposal();\n    error ProposalNotFound();\n    error AlreadyVoted();\n    error VotingSessionNotStarted();\n    error InvalidWorkflowStatus();\n    error VotingSessionNotEnded();\n\n    /// @notice Constructor that registers the initial voter\n    /// @param _initialVoter Address of the first voter to register\n    constructor(address _initialVoter) Ownable(msg.sender) {\n        if(_initialVoter != address(0)) {\n            _addVoter(_initialVoter);\n        }\n    }\n\n    /// @notice Modifier to check if caller is a registered voter\n    modifier onlyVoters() {\n        if(!voters[msg.sender].isRegistered) revert NotVoter();\n        _;\n    }\n\n    // ::::::::::::: GETTERS ::::::::::::: //\n\n    /// @notice Get voter information\n    /// @param _addr Address of the voter\n    /// @return Voter struct with voter information\n    function getVoter(address _addr) external view onlyVoters returns (Voter memory) {\n        return voters[_addr];\n    }\n\n    /// @notice Get a specific proposal\n    /// @param _id ID of the proposal\n    /// @return Proposal struct with proposal information\n    function getOneProposal(uint256 _id) external view onlyVoters returns (Proposal memory) {\n        if(_id >= proposalsArray.length) revert ProposalNotFound();\n        return proposalsArray[_id];\n    }\n\n    /// @notice Get all proposals at once (for frontend efficiency)\n    /// @return Array of all proposals\n    function getAllProposals() external view onlyVoters returns (Proposal[] memory) {\n        return proposalsArray;\n    }\n\n    /// @notice Get the number of proposals\n    /// @return Number of proposals\n    function getProposalsCount() external view returns (uint256) {\n        return proposalsArray.length;\n    }\n\n    /// @notice Get the winning proposal details after tally\n    /// @return Proposal struct of the winner\n    function getWinner() external view returns (Proposal memory) {\n        if(workflowStatus != WorkflowStatus.VotesTallied) revert InvalidWorkflowStatus();\n        return proposalsArray[winningProposalID];\n    }\n\n    // ::::::::::::: REGISTRATION ::::::::::::: //\n\n    /// @notice Register a new voter (only owner)\n    /// @param _addr Address of the voter to register\n    function addVoter(address _addr) external onlyOwner {\n        _addVoter(_addr);\n    }\n\n    /// @notice Internal function to register a voter\n    /// @param _addr Address of the voter to register\n    function _addVoter(address _addr) private {\n        if(workflowStatus != WorkflowStatus.RegisteringVoters) revert VotersRegistrationNotOpen();\n        if(voters[_addr].isRegistered) revert AlreadyRegistered();\n        if(_addr == address(0)) revert NotVoter();\n\n        voters[_addr].isRegistered = true;\n        unchecked {\n            ++votersCount; // Safe: unlikely to overflow\n        }\n\n        emit VoterRegistered(_addr);\n    }\n\n    /// @notice Register multiple voters at once (gas optimization)\n    /// @param _addresses Array of voter addresses to register\n    function addVoters(address[] calldata _addresses) external onlyOwner {\n        if(workflowStatus != WorkflowStatus.RegisteringVoters) revert VotersRegistrationNotOpen();\n\n        uint256 length = _addresses.length;\n        for(uint256 i; i < length;) {\n            address addr = _addresses[i];\n            if(!voters[addr].isRegistered && addr != address(0)) {\n                voters[addr].isRegistered = true;\n                unchecked {\n                    ++votersCount;\n                }\n                emit VoterRegistered(addr);\n            }\n            unchecked {\n                ++i; // Safe: array length is bounded\n            }\n        }\n    }\n\n    // ::::::::::::: PROPOSAL ::::::::::::: //\n\n    /// @notice Add a new proposal (only registered voters)\n    /// @param _desc Description of the proposal\n    function addProposal(string calldata _desc) external onlyVoters {\n        if(workflowStatus != WorkflowStatus.ProposalsRegistrationStarted) revert ProposalsRegistrationNotStarted();\n        if(bytes(_desc).length == 0) revert EmptyProposal();\n\n        proposalsArray.push(Proposal({\n            description: _desc,\n            voteCount: 0\n        }));\n\n        emit ProposalRegistered(proposalsArray.length - 1);\n    }\n\n    // ::::::::::::: VOTE ::::::::::::: //\n\n    /// @notice Vote for a proposal (only registered voters)\n    /// @param _id ID of the proposal to vote for\n    function setVote(uint256 _id) external onlyVoters nonReentrant {\n        if(workflowStatus != WorkflowStatus.VotingSessionStarted) revert VotingSessionNotStarted();\n\n        Voter storage voter = voters[msg.sender];\n        if(voter.hasVoted) revert AlreadyVoted();\n        if(_id >= proposalsArray.length) revert ProposalNotFound();\n\n        // Checks-Effects-Interactions pattern\n        voter.votedProposalId = _id;\n        voter.hasVoted = true;\n\n        unchecked {\n            ++proposalsArray[_id].voteCount; // Safe: unlikely to overflow\n        }\n\n        emit Voted(msg.sender, _id);\n    }\n\n    // ::::::::::::: WORKFLOW STATE CHANGES ::::::::::::: //\n\n    /// @notice Start the proposals registration session\n    function startProposalsRegistering() external onlyOwner {\n        if(workflowStatus != WorkflowStatus.RegisteringVoters) revert InvalidWorkflowStatus();\n\n        workflowStatus = WorkflowStatus.ProposalsRegistrationStarted;\n\n        // Add GENESIS proposal\n        proposalsArray.push(Proposal({\n            description: \"GENESIS\",\n            voteCount: 0\n        }));\n\n        emit WorkflowStatusChange(WorkflowStatus.RegisteringVoters, WorkflowStatus.ProposalsRegistrationStarted);\n    }\n\n    /// @notice End the proposals registration session\n    function endProposalsRegistering() external onlyOwner {\n        if(workflowStatus != WorkflowStatus.ProposalsRegistrationStarted) revert InvalidWorkflowStatus();\n\n        workflowStatus = WorkflowStatus.ProposalsRegistrationEnded;\n        emit WorkflowStatusChange(WorkflowStatus.ProposalsRegistrationStarted, WorkflowStatus.ProposalsRegistrationEnded);\n    }\n\n    /// @notice Start the voting session\n    function startVotingSession() external onlyOwner {\n        if(workflowStatus != WorkflowStatus.ProposalsRegistrationEnded) revert InvalidWorkflowStatus();\n\n        workflowStatus = WorkflowStatus.VotingSessionStarted;\n        emit WorkflowStatusChange(WorkflowStatus.ProposalsRegistrationEnded, WorkflowStatus.VotingSessionStarted);\n    }\n\n    /// @notice End the voting session\n    function endVotingSession() external onlyOwner {\n        if(workflowStatus != WorkflowStatus.VotingSessionStarted) revert InvalidWorkflowStatus();\n\n        workflowStatus = WorkflowStatus.VotingSessionEnded;\n        emit WorkflowStatusChange(WorkflowStatus.VotingSessionStarted, WorkflowStatus.VotingSessionEnded);\n    }\n\n    /// @notice Tally the votes and determine the winner\n    /// @dev Optimized loop with unchecked arithmetic\n    function tallyVotes() external onlyOwner {\n        if(workflowStatus != WorkflowStatus.VotingSessionEnded) revert VotingSessionNotEnded();\n\n        uint256 winningVoteCount;\n        uint256 winningProposalIndex;\n        uint256 proposalsLength = proposalsArray.length;\n\n        // Optimized loop\n        for(uint256 p; p < proposalsLength;) {\n            if(proposalsArray[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposalsArray[p].voteCount;\n                winningProposalIndex = p;\n            }\n            unchecked {\n                ++p; // Safe: bounded by array length\n            }\n        }\n\n        winningProposalID = winningProposalIndex;\n        workflowStatus = WorkflowStatus.VotesTallied;\n\n        emit WorkflowStatusChange(WorkflowStatus.VotingSessionEnded, WorkflowStatus.VotesTallied);\n    }\n\n    /// @notice Reset the voting system for a new session (only owner)\n    /// @dev Allows reusing the contract for multiple voting sessions\n    function resetVoting() external onlyOwner {\n        if(workflowStatus != WorkflowStatus.VotesTallied) revert InvalidWorkflowStatus();\n\n        // Reset workflow\n        workflowStatus = WorkflowStatus.RegisteringVoters;\n\n        // Clear proposals\n        delete proposalsArray;\n\n        // Reset winning proposal\n        winningProposalID = 0;\n\n        emit WorkflowStatusChange(WorkflowStatus.VotesTallied, WorkflowStatus.RegisteringVoters);\n    }\n}\n"
      }
    }
  }
}